using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using UnityEditor;
using UnityEngine.InputSystem;
using UnityEngine.InputSystem.Utilities;

namespace Cookie.InputHelper
{
    internal class InputWrapperGenerator
    {
        private readonly InputWrapperSettings _settings;

        private InputWrapperGenerator(InputWrapperSettings settings) => _settings = settings;

        [MenuItem("Tools/Input Wrapper/Generate")]
        private static void Generate() {
            InputWrapperSettings settings = InputWrapperSettings.GetInst();
            string folder = $"Assets/{settings.folder}";

            if (!Directory.Exists(folder)) Directory.CreateDirectory(folder);

            foreach (InputWrapperSettings.ActionsAsset actions in settings.assets) {
                InputWrapperGenerator generator = new(settings);
                string result = generator.GetCodeFor(actions);
                string path = $"{folder}/{actions.className}__Generated.cs";
                File.WriteAllText(path, result);
            }

            AssetDatabase.SaveAssets();
            AssetDatabase.Refresh();
        }

        private string GetCodeFor(InputWrapperSettings.ActionsAsset actions) {
            string @namespace = _settings.@namespace;
            InputActionAsset asset = actions.asset;

            StringBuilder sb = new();
            sb.AppendLine(
                @"// <auto-generated/>
using UnityEngine;
using UnityEngine.InputSystem;"
            );
            if (!string.IsNullOrWhiteSpace(actions.generatedNamespace))
                sb.AppendLine($"using {actions.generatedNamespace};");
            sb.AppendLine(
                @"#if UNITY_EDITOR
using UnityEditor;
#endif
"
            );

            string generatedClassPath = actions.generatedName;

            if (!string.IsNullOrWhiteSpace(@namespace)) sb.Append($"namespace {@namespace} {{");

            sb.Append(
                $@"
/// <summary>
///     A static wrapper around the '{asset.name}' input actions asset
/// </summary>
public static class @{actions.className}
{{
    #region Singleton
    private static {generatedClassPath} _inst = new();

    /// <summary>
    ///     Gets the instance of the generated C# class
    /// </summary>
    public static {generatedClassPath} Inst {{
        get {{
            if (_inst != null) return _inst;

            _inst = new {generatedClassPath}();
            _inst.Enable();

            return _inst;
        }}
    }}
    #endregion

    #region Action maps
    {GetActionMapDefinitions(asset, $"{generatedClassPath}")}
    #endregion

    #region Initialization
    #if UNITY_EDITOR
    [InitializeOnLoadMethod]
    private static void EditorInit() {{
        EditorApplication.playModeStateChanged -= OnPlaymodeStateChanged;
        EditorApplication.playModeStateChanged += OnPlaymodeStateChanged;

        return;

        void OnPlaymodeStateChanged(PlayModeStateChange change) {{
            if (change != PlayModeStateChange.ExitingPlayMode) return;
            _inst?.Dispose();
            _inst = null;
        }}
    }}
    #endif

    [RuntimeInitializeOnLoadMethod]
    private static void Init() {{
        _inst?.Enable();
    }}
    #endregion
}}"
            );

            string result;
            if (!string.IsNullOrWhiteSpace(@namespace)) {
                string noIndent = sb.ToString();
                List<string> splitByLine = new(noIndent.Split('\n'));
                StringBuilder indentBuilder = new();

                int namespaceIndex = splitByLine.FindIndex(s => s.StartsWith("namespace"));
                for (int i = 0; i < splitByLine.Count; i++) {
                    if (i > namespaceIndex) indentBuilder.Append("    ");
                    indentBuilder.AppendLine(splitByLine[i]);
                }

                indentBuilder.AppendLine("}");
                result = indentBuilder.ToString();
            } else {
                result = sb.ToString();
            }

            return result;
        }

        private string GetActionMapDefinitions(InputActionAsset asset, string generatedClass) {
            StringBuilder sb = new();

            foreach (InputActionMap map in asset.actionMaps) {
                string formattedMapName = ToPascalCase(map.name);
                sb.AppendLine($"\n    #region {map.name}");
                sb.AppendLine(
                    $@"
    /// <inheritdoc cref=""{generatedClass}.{formattedMapName}"" />
    public static {generatedClass}.{formattedMapName}Actions @{formattedMapName} {{ get; }} = Inst.{formattedMapName};"
                );

                foreach (InputAction action in map.actions) {
                    string formattedActionName = ToPascalCase(action.name);
                    string variableName = GetDistinctName(action, map, asset.actionMaps);

                    sb.AppendLine(
                        $@"
    /// <summary>
    ///     The '{action.name}' <see cref=""UnityEngine.InputSystem.InputAction"">action</see> from the '{map.name}' <see cref=""UnityEngine.InputSystem.InputActionMap"">input map</see>
    /// </summary>
    public static InputAction @{variableName} => {formattedMapName}.{formattedActionName};"
                    );
                }

                sb.AppendLine("\n    #endregion");
            }

            return sb.ToString();
        }

        private string GetDistinctName(
            InputAction action,
            InputActionMap map,
            ReadOnlyArray<InputActionMap> assetActionMaps
        ) {
            if (_settings.alwaysIncludeMap) return $"{map.name}_{action.name}";

            var otherActions = assetActionMaps.SelectMany(m => m.actions.Where(a => a != action));
            bool hasSame = otherActions.Select(a => a.name).Contains(action.name);

            return hasSame ? $"{map.name}_{action.name}" : action.name;
        }

        private static string ToPascalCase(string str) {
            StringBuilder sb = new(str);

            for (int i = sb.Length - 1; i >= 0; i--) {
                char c = sb[i];
                if (c == ' ') {
                    if (i < sb.Length - 1) sb[i + 1] = char.ToUpper(sb[i + 1]);
                    sb.Remove(i, 1);
                }
            }

            return sb.ToString();
        }
    }
}