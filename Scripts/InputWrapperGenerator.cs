using System.Collections.Generic;
using System.Text;
using CookieUtils;
using UnityCodeGen;
using UnityEngine.InputSystem;

namespace Cookie.InputWrapper
{
    [Generator]
// ReSharper disable once UnusedType.Global
    public class InputWrapperGenerator : ICodeGenerator
    {
        public void Execute(GeneratorContext context) {
            InputWrapperSettings settings = InputWrapperSettings.GetInst();
            context.OverrideFolderPath($"Assets/{settings.directory}");

            foreach (InputWrapperSettings.ActionsAsset actions in settings.assets) {
                InputActionAsset asset = actions.asset;

                StringBuilder sb = new(
                    @"// <auto-generated/>
using UnityEngine;
using UnityEngine.InputSystem;
#if UNITY_EDITOR
using UnityEditor;
#endif

"
                );

                string generatedClassPath = GetCSharpClassDefinition(actions);

                if (!settings.@namespace.IsNullOrWhiteSpace()) sb.AppendLine($"namespace {settings.@namespace} {{");

                sb.Append(
                    $@"/// <summary>
///     A static wrapper around the '{asset.name}' input actions asset
/// </summary>
public static class @{actions.className}
{{
    #region Singleton
    private static {generatedClassPath} _inst = new();

    /// <summary>
    ///     Gets the instance of the generated C# class
    /// </summary>
    public static {generatedClassPath} Inst {{
        get {{
            if (_inst != null) return _inst;

            _inst = new {generatedClassPath}();
            _inst.Enable();

            return _inst;
        }}
    }}
    #endregion

    #region Action maps
    {GetActionMapDefinitions(asset, $"{generatedClassPath}")}
    #endregion

    #region Initialization
    #if UNITY_EDITOR
    [InitializeOnLoadMethod]
    private static void EditorInit() {{
        EditorApplication.playModeStateChanged -= OnPlaymodeStateChanged;
        EditorApplication.playModeStateChanged += OnPlaymodeStateChanged;

        return;

        void OnPlaymodeStateChanged(PlayModeStateChange change) {{
            if (change != PlayModeStateChange.ExitingPlayMode) return;
            _inst?.Dispose();
            _inst = null;
        }}
    }}
    #endif

    [RuntimeInitializeOnLoadMethod]
    private static void Init() {{
        _inst?.Enable();
    }}
    #endregion
}}"
                );

                string result;
                if (!settings.@namespace.IsNullOrWhiteSpace()) {
                    string noIndent = sb.ToString();
                    List<string> splitByLine = new(noIndent.Split('\n'));
                    StringBuilder indentBuilder = new();

                    int namespaceIndex = splitByLine.FindIndex(s => s.StartsWith("namespace"));
                    for (int i = 0; i < splitByLine.Count; i++) {
                        if (i > namespaceIndex) indentBuilder.Append("    ");
                        indentBuilder.AppendLine(splitByLine[i]);
                    }

                    indentBuilder.AppendLine("}");
                    result = indentBuilder.ToString();
                } else {
                    result = sb.ToString();
                }

                context.AddCode($"{actions.className}.g.cs", result);
            }
        }

        private static string GetCSharpClassDefinition(InputWrapperSettings.ActionsAsset actions) {
            StringBuilder sb = new();
            if (!actions.generatedCSharpClassNamespace.IsNullOrWhiteSpace()) {
                sb.Append(actions.generatedCSharpClassNamespace);
                sb.Append(".");
            }

            sb.Append(actions.generatedCSharpClassName);

            return sb.ToString();
        }

        private static string GetActionMapDefinitions(InputActionAsset asset, string generatedClass) {
            StringBuilder sb = new();
            foreach (InputActionMap map in asset.actionMaps) {
                string formattedMapName = ToPascalCase(map.name);
                sb.AppendLine($"\n    #region {map.name}");
                sb.AppendLine(
                    $@"
    /// <inheritdoc cref=""{generatedClass}.{formattedMapName}"" />
    public static {generatedClass}.{formattedMapName}Actions @{formattedMapName} {{ get; }} = Inst.{formattedMapName};"
                );

                foreach (InputAction action in map.actions) {
                    string formattedActionName = ToPascalCase(action.name);
                    sb.AppendLine(
                        $@"
    /// <summary>
    ///     The '{action.name}' action from the '{map.name}' input map
    /// </summary>
    public static InputAction @{formattedActionName} => {formattedMapName}.{formattedActionName};"
                    );
                }

                sb.AppendLine("\n    #endregion");
            }

            return sb.ToString();
        }

        private static string ToPascalCase(string str) {
            List<char> charArray = new(str.ToCharArray());

            for (int i = charArray.Count - 1; i >= 0; i--) {
                char c = charArray[i];
                if (c == ' ') {
                    if (i < charArray.Count - 1) charArray[i + 1] = char.ToUpper(charArray[i + 1]);
                    charArray.RemoveAt(i);
                }
            }

            StringBuilder sb = new();
            sb.Append(charArray.ToArray());

            return sb.ToString();
        }
    }
}